//! Neuron categorical XYZP binary deserialization for FEAGI neural data.
//!
//! This module provides highly optimized deserialization of binary neuron data with
//! X, Y, Z coordinates and potential (P) values organized by cortical areas. It
//! reconstructs the efficient "struct of arrays" memory layout back into usable
//! FEAGI data structures for neural processing.
//!
//! ## Format Support
//!
//! - **Format Type**: 11 (Neuron Categorical XYZP)
//! - **Supported Versions**: 1
//! - **Byte Order**: Little-endian
//! - **Coordinate System**: Cartesian (X, Y, Z)
//! - **Data Types**: u32 for coordinates, f32 for potentials
//!
//! ## Binary Layout
//!
//! The deserializer processes byte streams with this structure:
//! ```text
//! [Global Header: 2 bytes]
//! [Cortical Count: 2 bytes]
//! [Cortical Descriptor 1: 14 bytes]...[Cortical Descriptor N: 14 bytes]
//! [Neuron Data 1: Variable][Neuron Data 2: Variable]...[Neuron Data N: Variable]
//! ```
//!
//! ## Memory Reconstruction
//!
//! The deserializer reconstructs neuron data from the quarter-based layout:
//! - First quarter: All X coordinates → Vec<u32>
//! - Second quarter: All Y coordinates → Vec<u32>
//! - Third quarter: All Z coordinates → Vec<u32>
//! - Fourth quarter: All potential values → Vec<f32>

use std::sync::Arc;
use bytemuck::{cast_slice};
use byteorder::{ByteOrder, LittleEndian};
use crate::error::DataProcessingError;
use crate::neuron_data::{CorticalMappedNeuronData, NeuronXYZPArrays};
use crate::cortical_data::CorticalID;
use super::{FeagiByteDeserializer, FeagiByteStructureType, verify_header_of_full_structure_bytes};

/// Neuron categorical XYZP binary deserializer for FEAGI neural data (Format Type 11, Version 1).
///
/// This deserializer processes byte streams containing binary neuron data serialized by the
/// corresponding [`NeuronCategoricalXYZPSerializerV1`]. It reconstructs cortical-organized
/// neuron data from the optimized quarter-based binary layout back into structured
/// [`CorticalMappedNeuronData`] objects.
///
/// ## Lifetime Management
///
/// The deserializer maintains a reference to the original byte data, enabling efficient
/// zero-copy deserialization where possible. The bytemuck crate is used for safe
/// reinterpretation of byte data as numeric arrays.
///
/// ## Format Validation
///
/// The deserializer performs comprehensive validation:
/// - Global header format and version verification
/// - Cortical count bounds checking
/// - Individual cortical descriptor validation
/// - Neuron data alignment and size verification
/// - ASCII cortical ID validation
///
/// ## Performance Characteristics
///
/// - **Speed**: Optimized for large neural datasets
/// - **Memory**: Zero-copy where possible, minimal allocation
/// - **Validation**: Comprehensive bounds and format checking
/// - **Output**: Direct conversion to FEAGI data structures
pub struct NeuronCategoricalXYZPDeserializerV1 {
    /// Reference to the complete byte slice containing the neuron categorical XYZP structure.
    /// This includes the global header, cortical count, cortical descriptors, and all neuron data.
    data_slice:  Arc<[u8]>,
}

impl FeagiByteDeserializer for NeuronCategoricalXYZPDeserializerV1 {
    /// Returns the format identifier for neuron categorical XYZP deserialization.
    ///
    /// # Returns
    /// 
    /// Always returns the value corresponding to `FeagiByteStructureType::NeuronCategoricalXYZP` (11)
    fn get_id(&self) -> u8 {FeagiByteStructureType::NeuronCategoricalXYZP as u8}
    
    /// Returns the version number for this neuron deserializer implementation.
    ///
    /// # Returns
    /// 
    /// Always returns `1` for this version of the neuron XYZP deserializer
    fn get_version(&self) -> u8 {1}
}

impl NeuronCategoricalXYZPDeserializerV1 {
    /// Creates a new neuron categorical XYZP deserializer from a byte slice.
    ///
    /// This constructor validates the global header to ensure the data is compatible
    /// with neuron XYZP deserialization. It verifies both the format type and version
    /// before creating the deserializer instance.
    ///
    /// # Arguments
    /// 
    /// * `data_slice` - Byte slice containing the complete neuron structure with global header
    ///
    /// # Returns
    /// 
    /// - `Ok(NeuronCategoricalXYZPDeserializerV1)`: Successfully created deserializer
    /// - `Err(DataProcessingError)`: Header validation failed
    ///
    /// # Errors
    /// 
    /// - `InvalidByteStructure`: Data too short, wrong format type, or wrong version
    ///
    /// # Examples
    /// 
    /// ```rust
    /// use feagi_core_data_structures_and_processing::byte_structures::deserializers_disabled::b011_neuron_categorical_xyzp::NeuronCategoricalXYZPDeserializerV1;
    ///
    /// // Valid neuron byte structure (minimal example with no neurons)
    /// let neuron_data = [11u8, 1u8, 0u8, 0u8]; // Type 11, Version 1, 0 cortical areas
    /// let deserializer = NeuronCategoricalXYZPDeserializerV1::from_data_slice(&neuron_data).unwrap();
    ///
    /// // Invalid format type will fail
    /// let invalid_data = [10u8, 1u8, 0u8, 0u8];
    /// assert!(NeuronCategoricalXYZPDeserializerV1::from_data_slice(&invalid_data).is_err());
    /// ```
    pub fn from_data_slice(data_slice: &[u8]) -> Result<NeuronCategoricalXYZPDeserializerV1, DataProcessingError> {
        verify_header_of_full_structure_bytes(data_slice, FeagiByteStructureType::NeuronCategoricalXYZP, 1)?;
        Ok(NeuronCategoricalXYZPDeserializerV1 { data_slice: Arc::from(data_slice) })
    }

    /// Deserializes the binary neuron data into cortical mapped neuron data structures.
    ///
    /// This method processes the complete binary neuron structure, extracting cortical
    /// descriptors and reconstructing neuron data arrays for each cortical area. The
    /// result is a HashMap mapping cortical IDs to their corresponding neuron data.
    ///
    /// # Returns
    /// 
    /// - `Ok(CorticalMappedNeuronData)`: Successfully reconstructed neuron data organized by cortical areas
    /// - `Err(DataProcessingError)`: Deserialization failed due to invalid data format
    ///
    /// # Errors
    /// 
    /// - `InvalidByteStructure`: Various format validation failures including:
    ///   - Container too short for expected cortical descriptors
    ///   - Neuron data size not divisible by 16 bytes (4 values × 4 bytes each)
    ///   - Data bounds exceed container size
    ///   - Invalid cortical ID format
    /// - Propagated errors from cortical ID creation and neuron array construction
    ///
    /// # Process
    /// 
    /// 1. Reads cortical area count from header
    /// 2. Validates container size for all cortical descriptors
    /// 3. Iterates through each cortical descriptor:
    ///    - Extracts cortical ID (6 ASCII bytes)
    ///    - Reads data position and length
    ///    - Validates data bounds
    ///    - Reconstructs neuron arrays from quarter-based layout
    /// 4. Creates CorticalMappedNeuronData with all cortical areas
    ///
    /// # Memory Layout Reconstruction
    /// 
    /// For each cortical area's neuron data:
    /// ```text
    /// Input:  [X₁X₂...Xₙ][Y₁Y₂...Yₙ][Z₁Z₂...Zₙ][P₁P₂...Pₙ]
    /// Output: NeuronXYCPArrays { x: Vec<u32>, y: Vec<u32>, c: Vec<u32>, p: Vec<f32> }
    /// ```
    fn to_cortical_mapped_neuron_data(&self) -> Result<CorticalMappedNeuronData, DataProcessingError> {
        // We don't have to verify the global header since that was checked on this struct being created
        // We also know it has at least 4 bytes
        const GLOBAL_HEADER_SIZE: usize = crate::byte_structures::GLOBAL_HEADER_SIZE;
        const CORTICAL_COUNT_HEADER_SIZE: usize = 2;

        let number_cortical_areas: u16 = LittleEndian::read_u16(&self.data_slice[2..4]);

        let min_array_length_with_cortical_headers: usize = GLOBAL_HEADER_SIZE +  CORTICAL_COUNT_HEADER_SIZE +
            (NeuronXYZPArrays::PER_CORTICAL_HEADER_DESCRIPTOR_SIZE * number_cortical_areas as usize);

        if self.data_slice.len() < min_array_length_with_cortical_headers {
            return Err(DataProcessingError::InvalidByteStructure(format!("Byte structure for NeuronCategoricalXYZPV1 needs a length of {} to fit just the cortical details header, but is a length of {}",
            min_array_length_with_cortical_headers, self.data_slice.len())));
        }

        let number_cortical_areas: usize = number_cortical_areas as usize;

        let mut output: CorticalMappedNeuronData = CorticalMappedNeuronData::with_capacity(number_cortical_areas);

        let mut reading_index: usize = GLOBAL_HEADER_SIZE + CORTICAL_COUNT_HEADER_SIZE;
        for _cortical_index in 0..number_cortical_areas {
            let cortical_id = CorticalID::from_bytes_at(
                &self.data_slice[reading_index..reading_index + 6]
            )?;
            let data_start_reading: usize = LittleEndian::read_u32(&self.data_slice[reading_index + 6..reading_index + 10]) as usize;
            let number_bytes_to_read: usize = LittleEndian::read_u32(&self.data_slice[reading_index + 10..reading_index + 14]) as usize * NeuronXYZPArrays::NUMBER_BYTES_PER_NEURON;
            
            if self.data_slice.len() < min_array_length_with_cortical_headers + data_start_reading + number_bytes_to_read {
                return Err(DataProcessingError::InvalidByteStructure("Byte structure for NeuronCategoricalXYZPV1 is too short to fit the data the header says it contains!".into()));
            }
            
            let neuron_bytes = &self.data_slice[data_start_reading..data_start_reading + number_bytes_to_read];
            let bytes_length = neuron_bytes.len();
            if bytes_length % NeuronXYZPArrays::NUMBER_BYTES_PER_NEURON != 0 {
                return Err(DataProcessingError::InvalidByteStructure("As NeuronXYCPArrays contains 4 internal arrays of equal length, each of elements of 4 bytes each (uint32 and float), the input byte array must be divisible by 16!".into()));
            }
            let x_end = bytes_length / 4;
            let y_end = bytes_length / 2;
            let c_end = x_end * 3;

            let neurons = NeuronXYZPArrays::new_from_vectors(
                cast_slice::<u8, u32>(&neuron_bytes[0..x_end]).to_vec(),
                cast_slice::<u8, u32>(&neuron_bytes[x_end..y_end]).to_vec(),
                cast_slice::<u8, u32>(&neuron_bytes[y_end..c_end]).to_vec(),
                cast_slice::<u8, f32>(&neuron_bytes[c_end..]).to_vec(),
            )?;

            output.insert(cortical_id, neurons);
            reading_index += NeuronXYZPArrays::PER_CORTICAL_HEADER_DESCRIPTOR_SIZE;
        };

        Ok(output)

    }

}