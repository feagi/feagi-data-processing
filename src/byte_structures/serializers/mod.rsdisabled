//! Serialization implementations for FEAGI data structures.
//!
//! This module contains serializer implementations for converting FEAGI data structures
//! into various byte formats. All serializers implement the [`FeagiByteSerializer`] trait
//! to provide a consistent interface across different serialization formats.
//!
//! ## Available Serializers
//!
//! - [`b001_json`]: JSON serialization for human-readable output
//! - [`b009_multi_struct_holder`]: Container format for multiple structures
//! - [`b011_neuron_categorical_xyzp`]: Efficient binary format for neuron data
//!
//! ## Trait Design
//!
//! The [`FeagiByteSerializer`] trait provides both new allocation and in-place
//! serialization methods:
//!
//! - `serialize_new()`: Creates a new Vec<u8> with the serialized data
//! - `serialize_in_place()`: Writes serialized data to an existing buffer

/// JSON serialization implementation (format type 1).
/// 
/// Provides human-readable JSON serialization of FEAGI data structures.
/// Suitable for debugging, configuration files, and scenarios where
/// readability is prioritized over performance.
pub mod b001_json;

/// Neuron categorical XYZP binary serialization implementation (format type 11).
/// 
/// Highly optimized binary serialization format specifically designed for
/// neuron data with X, Y, Z coordinates and potential values. Provides
/// maximum efficiency for large neuron datasets.
pub mod b011_neuron_categorical_xyzp;

/// Multi-structure container serialization implementation (format type 9).
/// 
/// Container format that can hold multiple different FEAGI structures
/// in a single serialized byte stream. Useful for batching operations
/// and reducing serialization overhead.
pub mod b009_multi_struct_holder;

use crate::byte_structures::FeagiByteStructureType;
use crate::error::DataProcessingError;
use super::feagi_byte_structure::FeagiFullByteData;

/// Trait defining the interface for all FEAGI byte structure serializers.
/// 
/// This trait provides a consistent interface for serializing FEAGI data structures
/// into byte formats. It supports both allocation-based and in-place serialization
/// methods to accommodate different performance requirements.
/// 
/// ## Implementation Requirements
/// 
/// Implementors must provide:
/// - Unique format ID and version numbers
/// - Size estimation for buffer allocation
/// - Both new allocation and in-place serialization methods
/// 
/// ## Thread Safety
/// 
/// While not currently enforced by trait bounds, implementations should consider
/// thread safety requirements for concurrent usage scenarios.
pub trait FeagiByteSerializer: Send + Sync{
    /// Returns the unique format identifier for this serializer.
    /// 
    /// This byte value is used in the global header to identify the serialization
    /// format when deserializing data. Must be unique across all serializer types.
    fn get_id(&self) -> u8;
    
    fn get_type(&self) -> Result<FeagiByteStructureType, DataProcessingError> {
        let result = FeagiByteStructureType::try_from(self.get_id());
        match result {
            Ok(t) => Ok(t),
            Err(e) => Err(DataProcessingError::InternalError(format!("Internal serializer attempted to report itself as nonexistant type {}!", self.get_id()))),
        }
    }
    
    /// Returns the version number for this serializer implementation.
    /// 
    /// Version numbers allow for format evolution while maintaining backward
    /// compatibility. Should be incremented when breaking changes are made
    /// to the serialization format.
    fn get_version(&self) -> u8;
    
    /// Returns the maximum possible size in bytes when this structure is serialized.
    /// 
    /// This is used for buffer allocation in in-place serialization scenarios.
    /// Should return a conservative upper bound to avoid buffer overflow errors.
    /// 
    /// # Returns
    /// 
    /// Maximum number of bytes that could be produced by serialization
    fn get_max_possible_size_when_serialized(&self) -> usize;
    
    /// Serializes the data structure into a new FeagiFullByteData
    /// 
    /// This method handles memory allocation internally and returns a 
    /// FeagiFullByteData that is ready to be sent to FEAGI
    /// 
    /// # Returns
    /// 
    /// - `Ok(FeagiFullByteData)`: Successfully serialized data
    /// - `Err(DataProcessingError)`: Serialization failed
    fn serialize_new(&self) -> Result<FeagiFullByteData, DataProcessingError>;

    /// Overwrites the generated data on top of an existing FeagiFullByteData slice,
    /// and returns the number of wasted allocated bytes at the end (compared 
    /// from max possible size when serialized)
    ///
    ///
    /// # Arguments
    ///
    /// * `write_target` - Mutable [u8] slice to write serialized data into
    ///
    /// # Returns
    ///
    /// - `Ok(usize)`: Number of bytes unused within the internal vector (wasted memory)
    /// - `Err(DataProcessingError)`: Serialization failed or buffer too small
    fn in_place_serialize(&self, write_target: &mut [u8]) -> Result<usize, DataProcessingError>;
}

