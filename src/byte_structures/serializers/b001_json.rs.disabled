//! JSON serialization implementation for FEAGI data structures.
//!
//! This module provides a JSON-based serializer that converts FEAGI data structures
//! into human-readable JSON format. It's particularly useful for debugging, configuration
//! files, logging, and situations where data interoperability and readability are more
//! important than serialization efficiency.
//!
//! ## Format Structure
//!
//! The JSON serializer produces byte streams with the following structure:
//! ```text
//! [Global Header: 2 bytes][JSON Data: Variable length]
//! ```
//!
//! - **Global Header**: [Type ID: 1][Version: 1]
//! - **JSON Data**: UTF-8 encoded JSON string
//!
//! ## Usage Examples
//!
//! ```rust
//! use serde_json::json;
//! use feagi_core_data_structures_and_processing::byte_structures::serializers::{
//!     FeagiByteSerializer, b001_json::JsonSerializerV1
//! };
//!
//! // Create a JSON serializer
//! let json_data = json!({
//!     "cortical_areas": ["iv00CC", "ov00CC"],
//!     "neuron_count": 1000
//! });
//! let serializer = JsonSerializerV1::from_json(json_data).unwrap();
//!
//! // Serialize to bytes
//! let serialized = serializer.serialize_new().unwrap();
//! ```
//!
//! ## Performance Considerations
//!
//! - JSON serialization is human-readable but less space-efficient than binary formats
//! - Parsing overhead makes it slower than binary alternatives
//! - Best suited for configuration, debugging, and small data sets
//! - Consider binary formats for high-frequency or large-scale data processing

use serde_json;
use crate::byte_structures::GLOBAL_HEADER_SIZE;
use crate::error::DataProcessingError;
use crate::byte_structures::feagi_byte_structure::FeagiFullByteData;
use super::FeagiByteSerializer;

/// JSON serializer implementation for FEAGI byte structures (Format Type 1, Version 1).
///
/// This serializer converts arbitrary JSON values into FEAGI's standardized byte format
/// with a global header followed by UTF-8 encoded JSON data. It provides human-readable
/// serialization suitable for debugging, configuration, and data interchange scenarios.
///
/// ## Format Details
///
/// - **Format ID**: 1
/// - **Version**: 1  
/// - **Structure**: [2-byte header][Variable-length JSON UTF-8 data]
/// - **Encoding**: UTF-8 for the JSON payload
///
/// ## Thread Safety
///
/// This struct is not thread-safe due to potential interior mutability of the JSON value.
/// Use appropriate synchronization when accessing from multiple threads.
pub struct JsonSerializerV1 {
    /// The JSON value to be serialized. Can be any valid serde_json::Value including
    /// objects, arrays, strings, numbers, booleans, or null.
    some_json: serde_json::Value,
}

impl FeagiByteSerializer for JsonSerializerV1 {
    /// Returns the format identifier for JSON serialization.
    ///
    /// # Returns
    /// 
    /// Always returns `1` to identify this as a JSON format in the global header.
    fn get_id(&self) -> u8 { 1 }
    
    /// Returns the version number for this JSON serializer implementation.
    ///
    /// # Returns
    /// 
    /// Always returns `1` for this version of the JSON serializer.
    fn get_version(&self) -> u8 { 1 }
    
    /// Calculates the maximum possible size when this JSON structure is serialized.
    ///
    /// This includes the global header plus the UTF-8 byte length of the JSON string.
    /// The calculation is performed by converting the JSON to a string and measuring
    /// its byte length, which provides an exact size rather than an estimate.
    ///
    /// # Returns
    /// 
    /// Total number of bytes required for serialization (header + JSON data)
    fn get_max_possible_size_when_serialized(&self) -> usize {
        self.some_json.to_string().len() + GLOBAL_HEADER_SIZE // TODO this is slow, any faster way to do this?
        // This is precise, good
    }
    
    /// Serializes the JSON data into a newly allocated byte vector.
    ///
    /// Creates a new vector with the exact capacity needed and writes the global header
    /// followed by the UTF-8 encoded JSON string data.
    ///
    /// # Returns
    /// 
    /// - `Ok(Vec<u8>)`: Successfully serialized data with global header
    /// - `Err(DataProcessingError)`: Serialization failed (rare for JSON)
    ///
    /// # Examples
    /// 
    /// ```rust
    /// use serde_json::json;
    /// use feagi_core_data_structures_and_processing::byte_structures::serializers::{
    ///     FeagiByteSerializer, b001_json::JsonSerializerV1
    /// };
    /// 
    /// let serializer = JsonSerializerV1::from_json(json!({"test": "value"})).unwrap();
    /// let bytes = serializer.serialize_new().unwrap();
    /// assert_eq!(bytes[0], 1); // Format ID
    /// assert_eq!(bytes[1], 1); // Version
    /// ```
    fn serialize_new(&self) -> Result<FeagiFullByteData, DataProcessingError> {
        let mut bytes = Vec::with_capacity(self.get_max_possible_size_when_serialized());
        bytes.push(self.get_id());
        bytes.push(self.get_version());
        bytes.extend(self.some_json.to_string().into_bytes());
        Ok(FeagiFullByteData::new(bytes)?)
    }
    
    fn in_place_serialize(&self, write_target: &mut [u8]) -> Result<usize, DataProcessingError> {
        // TODO we are technically NOT writing in place with this function!
        let write_data = self.some_json.to_string().into_bytes();
        let required_size = write_data.len() + GLOBAL_HEADER_SIZE;
        if write_target.len() < required_size {
            return Err(DataProcessingError::IncompatibleInplace(format!("Json structure needs {} bytes of space but only {} was provided!",
                                                                        required_size, write_target.len())));
        }
        
        write_target[0] = self.get_id();
        write_target[1] = self.get_version();
        write_target[2..required_size].copy_from_slice(&write_data);

        let wasted_space = write_target.len() - required_size;
        Ok(wasted_space)
    }
    
}

impl JsonSerializerV1 {
    /// Creates a new JSON serializer from a serde_json::Value.
    ///
    /// This constructor accepts any valid JSON value including objects, arrays,
    /// primitives, and null values. The JSON value is stored internally and will
    /// be serialized when the serializer methods are called.
    ///
    /// # Arguments
    /// 
    /// * `json` - A serde_json::Value containing the data to be serialized
    ///
    /// # Returns
    /// 
    /// - `Ok(JsonSerializerV1)`: Successfully created serializer
    /// - `Err(DataProcessingError)`: Currently always succeeds, but returns Result for API consistency
    ///
    /// # Examples
    /// 
    /// ```rust
    /// use serde_json::json;
    /// use feagi_core_data_structures_and_processing::byte_structures::serializers::b001_json::JsonSerializerV1;
    /// 
    /// // Create from object
    /// let serializer = JsonSerializerV1::from_json(json!({
    ///     "neurons": [1, 2, 3],
    ///     "cortical_id": "iv00CC"
    /// })).unwrap();
    /// 
    /// // Create from array
    /// let array_serializer = JsonSerializerV1::from_json(json!([1, 2, 3])).unwrap();
    /// 
    /// // Create from primitive
    /// let string_serializer = JsonSerializerV1::from_json(json!("test")).unwrap();
    /// ```
    pub fn from_json(json: serde_json::Value) -> Result<JsonSerializerV1, DataProcessingError> {
        Ok(JsonSerializerV1 { some_json: json })
    }
    
    /// Provides mutable access to the internal JSON value.
    ///
    /// This method allows modification of the JSON data after the serializer has been created.
    /// Useful for updating values before serialization or for building JSON data incrementally.
    ///
    /// # Returns
    /// 
    /// Mutable reference to the internal serde_json::Value
    ///
    /// # Examples
    /// 
    /// ```rust
    /// use serde_json::json;
    /// use feagi_core_data_structures_and_processing::byte_structures::serializers::b001_json::JsonSerializerV1;
    /// 
    /// let mut serializer = JsonSerializerV1::from_json(json!({})).unwrap();
    /// 
    /// // Modify the JSON data
    /// let json_ref = serializer.as_mut();
    /// json_ref["new_field"] = json!("new_value");
    /// json_ref["neuron_count"] = json!(42);
    /// ```
    pub fn as_mut(&mut self) -> &mut serde_json::Value {
        &mut self.some_json
    }
}